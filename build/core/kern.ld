OUTPUT_FORMAT(elf32-littlearm)
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
 . = (0x2ffc0000 + (0x2ffc0000 - 0x2ffc0000));
 ASSERT(!((0x2ffc0000 + (0x2ffc0000 - 0x2ffc0000)) & 31), "text start should align to 32bytes")
 __text_start = .;
 __flatmap_unpg_rx_start = ((__text_start) - ((__text_start) % ((1 << (12)))));
 .text : {
  KEEP(*(.text._start))
  __identity_map_init_start = .;
  *(.identity_map .identity_map.*
    .text.get_core_pos_mpidr)
  __identity_map_init_end = .;
  KEEP(*(.text.init .text.plat_cpu_reset_early .text.reset .text.reset_primary .text.unhandled_cpu .text.__assert_flat_mapped_range))
  *(.text)
 *(.text.udelay)
 *(.text.mdelay)
 *(.text.cpu_idle)
 *(.text.plat_prng_add_jitter_entropy)
 *(.text.__cpu_spin_lock)
 *(.text.__cpu_spin_trylock)
 *(.text.__cpu_spin_unlock)
 *(.text.tlbi_all)
 *(.text.tlbi_mva_allasid)
 *(.text.dcache_cleaninv_range)
 *(.text.dcache_clean_range)
 *(.text.dcache_inv_range)
 *(.text.dcache_clean_range_pou)
 *(.text.do_dcsw_op)
 *(.text.dcache_op_louis)
 *(.text.dcache_op_all)
 *(.text.dcache_op_level1)
 *(.text.icache_inv_all)
 *(.text.icache_inv_range)
 *(.text.thread_set_abt_sp)
 *(.text.thread_set_und_sp)
 *(.text.thread_set_irq_sp)
 *(.text.thread_set_fiq_sp)
 *(.text.thread_resume)
 *(.text.thread_save_state)
 *(.text.thread_init_vbar)
 *(.text.thread_unwind_user_mode)
 *(.text.thread_excp_vect)
 *(.text.thread_check_canaries)
 *(.text.thread_lock_global)
 *(.text.thread_unlock_global)
 *(.text.thread_get_exceptions)
 *(.text.thread_set_exceptions)
 *(.text.thread_mask_exceptions)
 *(.text.thread_unmask_exceptions)
 *(.text.thread_get_core_local)
 *(.text.thread_clr_boot_thread)
 *(.text.thread_get_tmp_sp)
 *(.text.thread_is_from_abort_mode)
 *(.text.thread_get_id_may_fail)
 *(.text.thread_lazy_save_ns_vfp)
 *(.text.thread_resume_from_rpc)
 *(.text.thread_alloc_and_run)
 *(.text.thread_lazy_restore_ns_vfp)
 *(.text.thread_state_free)
 *(.text.thread_get_id)
 *(.text.thread_init_thread_core_local)
 *(.text.thread_init_per_cpu)
 *(.text.thread_get_tsd)
 *(.text.thread_get_ctx_regs)
 *(.text.thread_restore_foreign_intr)
 *(.text.thread_kernel_save_vfp)
 *(.text.thread_kernel_restore_vfp)
 *(.text.thread_user_enable_vfp)
 *(.text.thread_user_save_vfp)
 *(.text.thread_state_suspend)
 *(.text.thread_svc_handler)
 *(.text.mobj_matches)
 *(.text.mobj_get_cookie)
 *(.text.rpc_shm_mobj_alloc)
 *(.text.thread_rpc_free_arg)
 *(.text.mobj_get_va.constprop.0)
 *(.text.get_rpc_arg.constprop.0)
 *(.text.thread_handle_fast_smc)
 *(.text.thread_handle_std_smc)
 *(.text.thread_disable_prealloc_rpc_cache)
 *(.text.thread_enable_prealloc_rpc_cache)
 *(.text.thread_rpc_cmd)
 *(.text.thread_std_smc_entry)
 *(.text.thread_rpc)
 *(.text.thread_foreign_intr_exit)
 *(.text.save_abort_info_in_tsd)
 *(.text.__print_abort_info)
 *(.text.handle_user_mode_panic.isra.0)
 *(.text.abort_print)
 *(.text.abort_print_error)
 *(.text.abort_is_user_exception)
 *(.text.abort_is_write_fault)
 *(.text.abort_handler)
 *(.text.vfp_is_enabled)
 *(.text.vfp_enable)
 *(.text.vfp_disable)
 *(.text.vfp_lazy_save_state_init)
 *(.text.vfp_lazy_save_state_final)
 *(.text.vfp_lazy_restore_state)
 *(.text.vfp_save_extension_regs)
 *(.text.vfp_restore_extension_regs)
 *(.text.vfp_write_fpexc)
 *(.text.vfp_read_fpexc)
 *(.text.vfp_write_fpscr)
 *(.text.vfp_read_fpscr)
 *(.text.plat_trace_ext_puts)
 *(.text.trace_ext_puts)
 *(.text.trace_ext_get_thread_id)
 *(.text.trace_ext_get_core_id)
 *(.text.get_core_pos_mpidr)
 *(.text.temp_set_mode)
 *(.text.read_mode_sp)
 *(.text.read_mode_lr)
 *(.text.plat_primary_init_early)
 *(.text.init_sec_mon)
 *(.text.boot_init_secondary)
 *(.text.boot_set_core_ns_entry)
 *(.text.boot_core_release)
 *(.text.boot_core_hpen)
 *(.text.unhandled_cpu)
 *(.text.dummy.boot_init_primary_late)
 *(.text.dummy.__thread_std_smc_entry)
 *(.text.dummy.core_init_mmu_map)
 *(.text.dummy.boot_init_primary_early)
 *(.text.pa_is_in_map)
 *(.text.find_map_by_type_and_pa)
 *(.text.find_map_by_pa)
 *(.text._pbuf_is_inside)
 *(.text.phys_to_virt.part.0)
 *(.text.core_mmu_nsec_ddr_is_defined)
 *(.text.core_mmu_type_to_attr)
 *(.text.core_pbuf_is)
 *(.text.tlbi_mva_range)
 *(.text.core_mmu_set_entry)
 *(.text.core_mmu_get_entry)
 *(.text.virt_to_phys)
 *(.text.phys_to_virt)
 *(.text.phys_to_virt_io)
 *(.text.cpu_mmu_enabled)
 *(.text.io_pa_or_va)
 *(.text.io_pa_or_va_secure)
 *(.text.get_pgt_count)
 *(.text.find_pager_table_may_fail)
 *(.text.region_va2tblidx)
 *(.text.pmem_assign_fobj_page)
 *(.text.pmem_find)
 *(.text.tblidx_get_entry)
 *(.text.tblidx_set_entry)
 *(.text.to_user_mode_ctx)
 *(.text.tblidx_tlbi_entry)
 *(.text.find_region)
 *(.text.find_uta_region)
 *(.text.fobj_get)
 *(.text.pager_unlock)
 *(.text.make_dirty_page.isra.0)
 *(.text.get_pmem_pa.isra.0)
 *(.text.pager_deploy_page)
 *(.text.tee_pager_unhide_page)
 *(.text.make_iv_available)
 *(.text.pmem_get_region_tblidx.isra.0)
 *(.text.pmem_unmap)
 *(.text.pager_lock_check_stack)
 *(.text.region_insert)
 *(.text.unlink_region)
 *(.text.merge_region_with_next)
 *(.text.tee_pager_invalidate_fobj)
 *(.text.split_region)
 *(.text.rem_region)
 *(.text.tee_pager_pgt_save_and_release_entries)
 *(.text.tee_pager_release_phys)
 *(.text.tee_pager_set_um_region_attr)
 *(.text.tee_pager_get_table_info)
 *(.text.tee_pager_phys_to_virt)
 *(.text.tee_pager_handle_fault)
 *(.text.core_mmu_set_entry_primitive)
 *(.text.core_mmu_get_entry_primitive)
 *(.text.core_mmu_user_mapping_is_active)
 *(.text.core_mmu_get_user_map)
 *(.text.core_mmu_set_user_map)
 *(.text.core_mmu_get_fault_type)
 *(.text.cpu_spin_lock_xsave_no_dldetect)
 *(.text.cpu_spin_unlock_xrestore)
 *(.text.mobj_reg_shm_get_pa)
 *(.text.mobj_put)
 *(.text.mobj_reg_shm_alloc)
 *(.text.mobj_mapped_shm_alloc)
 *(.text.tee_entry_get_api_call_count)
 *(.text.tee_entry_get_api_uuid)
 *(.text.tee_entry_get_api_revision)
 *(.text.tee_entry_get_os_uuid)
 *(.text.tee_entry_get_os_revision)
 *(.text.__tee_entry_fast)
 *(.text.tee_entry_fast)
 *(.text.stm32mp1_itamper_action)
 *(.text.stm32mp1_etamper_action)
 *(.text.stm32_dbgmcu_base)
 *(.text.console_init)
 *(.text.stm32mp1_dbgmcu_get_chip_dev_id)
 *(.text.get_part_number.constprop.0)
 *(.text.itr_core_handler)
 *(.text.main_secondary_init_gic)
 *(.text.get_gicc_base)
 *(.text.get_gicd_base)
 *(.text.may_spin_lock)
 *(.text.may_spin_unlock)
 *(.text.stm32mp_bkpreg)
 *(.text.stm32mp_bkpsram_base)
 *(.text.stm32mp_stgen_base)
 *(.text.stm32mp_supports_hw_cryp)
 *(.text.stm32mp_supports_second_core)
 *(.text.plat_cpu_reset_early)
 *(.text.plat_scmi_get_channel)
 *(.text.stm32_scmi_pm)
 *(.text.io_mask32_stm32shregs)
 *(.text.stm32mp_tzc_region0)
 *(.text.stm32mp_tzc_reset_region)
 *(.text.stm32mp1_tzc_pm)
 *(.text.stm32mp1_clk_hsi_get_cal)
 *(.text.stm32mp1_clk_hsi_set_trim)
 *(.text.stm32mp1_clk_csi_get_cal)
 *(.text.stm32mp1_clk_csi_set_trim)
 *(.text.get_freq)
 *(.text.stm32mp1_calib_pm)
 *(.text.stm32mp_start_clock_calib)
 *(.text.stm32mp_alarm_calib)
 *(.text.get_ddrctrl_base)
 *(.text.do_sw_handshake)
 *(.text.ddr_set_sr_mode)
 *(.text.timeout_init_us.constprop.0)
 *(.text.do_sw_ack)
 *(.text.get_ddrphy_calibration)
 *(.text.ddr_standby_sr_entry)
 *(.text.ddr_standby_sr_exit)
 *(.text.ddr_save_sr_mode)
 *(.text.ddr_restore_sr_mode)
 *(.text.pmic_set_flag)
 *(.text.pmic_list_voltages)
 *(.text.pmic_get_voltage)
 *(.text.pmic_set_voltage)
 *(.text.pmic_get_state)
 *(.text.pmic_set_state)
 *(.text.driver_suspend)
 *(.text.pmic_pm)
 *(.text.stm32mp_with_pmic)
 *(.text.stm32mp_get_pmic)
 *(.text.driver_lock)
 *(.text.stm32mp_put_pmic)
 *(.text.driver_unlock)
 *(.text.stm32mp_pm_get_pmic)
 *(.text.pwr_get_voltage)
 *(.text.pwr_list_voltages)
 *(.text.pwr_regul_unlock)
 *(.text.pwr_regul_lock)
 *(.text.stm32_pwr_base)
 *(.text.pwr_get_state)
 *(.text.pwr_set_state)
 *(.text.stm32_rcc_base)
 *(.text.stm32_reset_system)
 *(.text.get_syscfg_base)
 *(.text.syscfg_hslv_pm)
 *(.text.stm32mp_syscfg_enable_io_compensation)
 *(.text.stm32mp_syscfg_disable_io_compensation)
 *(.text.sm_platform_handler)
 *(.text.pm_domain_scv_handler)
 *(.text.pwr_scv_handler)
 *(.text.get_retram_resume_ctx)
 *(.text.load_earlyboot_pm_mailbox)
 *(.text.enable_pm_mailbox)
 *(.text.gate_pm_context_clocks.part.0)
 *(.text.gate_pm_context_clocks.constprop.0)
 *(.text.stm32mp_pm_wipe_context)
 *(.text.stm32mp_pm_save_context)
 *(.text.stm32mp_pm_restore_context)
 *(.text.stm32mp_pm_shutdown_context)
 *(.text.cpu_wfi)
 *(.text.stm32mp_mask_timer)
 *(.text.rcc_wakeup_it_handler)
 *(.text.sgi9_it_handler)
 *(.text.stm32_pm_cpu_wfi)
 *(.text.stm32_enter_cstop)
 *(.text.stm32_exit_cstop)
 *(.text.stm32mp_gic_set_end_of_interrupt)
 *(.text.stm32_enter_cstop_shutdown)
 *(.text.stm32_enter_csleep)
 *(.text.plat_panic)
 *(.text.stm32_pm_cpu_power_down_wfi)
 *(.text.stm32mp_bkpsram_resume)
 *(.text.stm32mp_ccm_encrypt_teeram)
 *(.text.stm32mp_sysram_resume)
 *(.text.stm32mp_cpu_reset_state)
 *(.text.get_pm_domain_state)
 *(.text.stm32mp1_is_retram_during_standby)
 *(.text.need_to_backup_cpu_context)
 *(.text.need_to_backup_stop_context)
 *(.text.stm32mp1_set_pm_domain_state)
 *(.text.stm32mp1_get_lp_soc_mode)
 *(.text.plat_suspend)
 *(.text.psci_affinity_info)
 *(.text.stm32mp_register_online_cpu)
 *(.text.psci_cpu_on)
 *(.text.psci_cpu_off)
 *(.text.psci_system_suspend)
 *(.text.psci_system_off)
 *(.text.psci_system_reset)
 *(.text.psci_features)
 *(.text.psci_version)
 *(.text.sm_save_unbanked_regs)
 *(.text.sm_restore_unbanked_regs)
 *(.text.sm_smc_entry)
 *(.text.sm_fiq_entry)
 *(.text.sm_vect_table)
 *(.text.sm_vect_table_a15)
 *(.text.sm_vect_table_bpiall)
 *(.text.sm_init)
 *(.text.sm_get_nsec_ctx)
 *(.text.sm_from_nsec)
 *(.text.sm_pm_cpu_suspend_save)
 *(.text.sm_pm_cpu_suspend)
 *(.text.sm_pm_cpu_do_suspend)
 *(.text.sm_pm_cpu_resume)
 *(.text.sm_pm_cpu_do_resume)
 *(.text.smc_std_handler)
 *(.text.psci_cpu_suspend)
 *(.text.psci_migrate)
 *(.text.psci_migrate_info_type)
 *(.text.psci_migrate_info_up_cpu)
 *(.text.psci_mem_protect)
 *(.text.psci_mem_chk_range)
 *(.text.psci_system_reset2)
 *(.text.psci_node_hw_state)
 *(.text.tee_psci_handler)
 *(.text.psci_disable_smp)
 *(.text.psci_armv7_cpu_off)
 *(.text.ghash_update_lengths)
 *(.text.__gcm_update_aad)
 *(.text.internal_aes_gcm_inc_ctr)
 *(.text.__gcm_init)
 *(.text.__gcm_update_payload)
 *(.text.operation_final)
 *(.text.internal_aes_gcm_enc)
 *(.text.internal_aes_gcm_dec)
 *(.text.ghash_update_block)
 *(.text.decrypt_block)
 *(.text.encrypt_block)
 *(.text.internal_aes_gcm_set_key)
 *(.text.internal_aes_gcm_ghash_update)
 *(.text.internal_aes_gcm_update_payload_blocks)
 *(.text.internal_aes_gcm_ghash_gen_tbl)
 *(.text.internal_aes_gcm_ghash_mult_tbl)
 *(.text.crypto_rng_add_event)
 *(.text.tzc_configure_region)
 *(.text.gic_op_set_pmr)
 *(.text.gic_op_set_ipriority)
 *(.text.gic_save_it)
 *(.text.gic_op_set_affinity.part.0)
 *(.text.gic_op_raise_pi)
 *(.text.gic_op_disable)
 *(.text.gic_op_enable)
 *(.text.gic_it_set_cpu_mask.isra.0)
 *(.text.gic_op_set_affinity)
 *(.text.gic_op_add)
 *(.text.gic_op_raise_sgi)
 *(.text.gic_restore_it)
 *(.text.gic_cpu_init)
 *(.text.gic_init_setup)
 *(.text.gic_pm)
 *(.text.gic_it_handle)
 *(.text.bsec_base)
 *(.text.bsec_status)
 *(.text.is_invalid_mode)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout.part.0)
 *(.text.stm32_bsec_read_otp)
 *(.text.stm32_bsec_write_debug_conf)
 *(.text.stm32_bsec_read_debug_conf)
 *(.text.bsec_pm)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout)
 *(.text.stm32_gpio_get_bank)
 *(.text.stm32_gpio_set_level)
 *(.text.stm32_gpio_get_level)
 *(.text.set_gpio_cfg)
 *(.text.stm32_gpio_pm)
 *(.text.stm32_gpio_get_ops)
 *(.text.stm32_pinctrl_get_gpio_id)
 *(.text.stm32_pinctrl_load_config)
 *(.text.iwdg_refresh)
 *(.text.stm32_iwdg_it_handler)
 *(.text.stm32_iwdg_refresh)
 *(.text.timeout_init_us)
 *(.text.get_base)
 *(.text.i2c_ack_failed)
 *(.text.i2c_transfer_config)
 *(.text.i2c_wait_stop)
 *(.text.wait_isr_event)
 *(.text.i2c_wait_txis)
 *(.text.stm32_i2c_read_write_membyte)
 *(.text.stm32_i2c_resume)
 *(.text.stm32_i2c_suspend)
 *(.text.conceal_seed_error.constprop.0)
 *(.text.stm32_rng_pm)
 *(.text.get_rng_bytes_relaxed)
 *(.text.crypto_rng_read)
 *(.text.stm32_is_a_leap_year)
 *(.text.stm32_rtc_get_second_fraction)
 *(.text.stm32_rtc_read_calendar)
 *(.text.stm32_rtc_get_date.isra.0)
 *(.text.stm32_rtc_get_time.isra.0)
 *(.text.stm32_rtc_get_calendar)
 *(.text.stm32_rtc_diff_calendar)
 *(.text.loc_have_rx_data)
 *(.text.loc_putc)
 *(.text.loc_flush)
 *(.text.loc_getchar)
 *(.text.stm32_uart_init)
 *(.text.get_regulator_data)
 *(.text.voltage_to_index)
 *(.text.find_plat_mask)
 *(.text.stpmic1_regu_has_lp_cfg)
 *(.text.stpmic1_regulator_levels_mv)
 *(.text.stpmic1_register_read)
 *(.text.stpmic1_is_regulator_enabled)
 *(.text.stpmic1_regulator_voltage_get)
 *(.text.stpmic1_register_write)
 *(.text.stpmic1_lp_copy_reg)
 *(.text.stpmic1_register_update)
 *(.text.stpmic1_switch_off)
 *(.text.stpmic1_regulator_enable)
 *(.text.stpmic1_regulator_disable)
 *(.text.stpmic1_regulator_voltage_set)
 *(.text.stpmic1_regulator_pull_down_set)
 *(.text.stpmic1_regulator_mask_reset_set)
 *(.text.stpmic1_regulator_icc_set)
 *(.text.stpmic1_regulator_sink_mode_set)
 *(.text.stpmic1_regulator_bypass_mode_set)
 *(.text.stpmic1_active_discharge_mode_set)
 *(.text.stpmic1_lp_reg_on_off)
 *(.text.stpmic1_lp_set_voltage)
 *(.text.cpu_spin_lock_xsave_no_dldetect.constprop.0)
 *(.text.counter_start)
 *(.text.counter_stop)
 *(.text.counter_get_value)
 *(.text.stm32_tim_counter_release_config)
 *(.text.stm32_tim_counter_stop)
 *(.text.stm32_tim_counter_start)
 *(.text.stm32_tim_counter_get_value)
 *(.text.stm32_tim_counter_set_config)
 *(.text.etzpc_configure_decprot)
 *(.text.etzpc_lock_decprot)
 *(.text.etzpc_lock_tzma)
 *(.text.etzpc_pm)
 *(.text.clk_disable_no_lock)
 *(.text.clk_enable_no_lock)
 *(.text.clk_is_enabled)
 *(.text.clk_enable)
 *(.text.clk_disable)
 *(.text.clk_get_rate)
 *(.text.clock_id_to_clk)
 *(.text.save_pll34_state)
 *(.text.enable_kernel_clocks)
 *(.text.pll_start)
 *(.text.__clk_enable)
 *(.text.__clk_disable)
 *(.text.clk_op_disable)
 *(.text.pll_compute_pllxcfgr1.constprop.0)
 *(.text.clk_op_enable)
 *(.text.stm32mp1_read_pll_freq)
 *(.text.get_clock_rate)
 *(.text.stm32mp1_set_clkdiv)
 *(.text.pll_output)
 *(.text.restore_pll34_state)
 *(.text.stm32mp1_set_clksrc)
 *(.text.pll1_config_from_opp_khz)
 *(.text.stm32_clock_pm)
 *(.text.stm32mp1_clk_lp_save_opp_pll1_settings)
 *(.text.stm32mp_rcc_clock_id_to_clk)
 *(.text.stm32mp1_clk_save_context_for_stop)
 *(.text.stm32mp1_clk_restore_context_for_stop)
 *(.text._regulator_set_state.isra.0)
 *(.text.unlock_driver.isra.0)
 *(.text.lock_driver.isra.0)
 *(.text.regulator_disable)
 *(.text._regulator_enable)
 *(.text.regulator_enable)
 *(.text.regulator_pm)
 *(.text.fixed_set_state)
 *(.text.fixed_get_state)
 *(.text.gpio_list_voltages)
 *(.text.gpio_get_voltage)
 *(.text.gpio_set_voltage)
 *(.text.scmi_smt_init_agent_channel)
 *(.text.console_putc)
 *(.text.console_flush)
 *(.text.register_serial_console)
 *(.text.call_callbacks)
 *(.text.pm_change_state)
 *(.text.itr_handle)
 *(.text.itr_raise_sgi)
 *(.text.itr_set_pmr)
 *(.text.itr_set_ipriority)
 *(.text.__do_panic)
 *(.text.refcount_inc)
 *(.text.refcount_dec)
 *(.text.is_valid_conf_and_notnull_size)
 *(.text.core_is_buffer_inside)
 *(.text.ts_get_current_session_may_fail)
 *(.text.ts_get_current_session)
 *(.text.__mutex_unlock.constprop.0)
 *(.text.__mutex_lock.constprop.0)
 *(.text.mutex_unlock)
 *(.text.mutex_lock)
 *(.text.wq_wait_init_condvar)
 *(.text.wq_wait_final)
 *(.text.wq_wake_next)
 *(.text.notif_rpc)
 *(.text.notif_wait)
 *(.text.notif_send_sync)
 *(.text.is_user_ta_ctx)
 *(.text.mobj_phys_get_va)
 *(.text.mobj_phys_get_pa)
 *(.text.mobj_mm_get_pa)
 *(.text.mobj_with_fobj_get_pa)
 *(.text.mobj_shm_get_pa)
 *(.text.mobj_mm_get_va)
 *(.text.mobj_shm_alloc)
 *(.text.rwp_paged_iv_get_iv_vaddr)
 *(.text.rop_save_page)
 *(.text.rwp_save_page)
 *(.text.rwp_paged_iv_save_page)
 *(.text.lop_load_page)
 *(.text.rop_load_page)
 *(.text.rwp_load_page)
 *(.text.rwp_paged_iv_load_page)
 *(.text.rwp_unpaged_iv_load_page)
 *(.text.lop_save_page)
 *(.text.rwp_unpaged_iv_save_page)
 *(.text.mobj_get_pa)
 *(.text.vm_pa2va)
 *(.text.hash_sha256_check)
 *(.text.crypto_aes_enc_block)
 *(.text.rijndael_ecb_encrypt)
 *(.text.sha256_init)
 *(.text._sha256_compress)
 *(.text.sha256_compress)
 *(.text.sha256_done)
 *(.text.sha256_process)
 *(.text.burn_stack)
 *(.text.zeromem)
 *(.text.buf_get_pos)
 *(.text.raw_malloc_return_hook)
 *(.text.bget)
 *(.text.bgetz)
 *(.text.brel)
 *(.text.bgetr)
 *(.text.raw_free)
 *(.text.free_helper)
 *(.text.raw_calloc)
 *(.text.raw_realloc)
 *(.text.calloc)
 *(.text.realloc)
 *(.text.free)
 *(.text.memchr)
 *(.text.memcpy)
 *(.text.memset)
 *(.text.strcmp)
 *(.text.strlen)
 *(.text.strncmp)
 *(.text.__aeabi_uldivmod)
 *(.text.ul_div_qr)
 *(.text.__ul_divmod)
 *(.text.__vsnprintf)
 *(.text.vsnprintk)
 *(.text.snprintk)
 *(.text.kprintf.constprop.0)
 *(.text.trace_vprintf)
 *(.text.trace_printf)
 *(.text.consttime_memcmp)
 *(.text.memzero_explicit)
  *(.sram.text.glue_7* .gnu.linkonce.t.*)
  . = ALIGN(8);
 }
 __text_end = .;
 __flatmap_unpg_rx_size = . - __flatmap_unpg_rx_start;
 __flatmap_unpg_ro_start = .;
 .rodata : ALIGN(8) {
  __rodata_start = .;
  *(.gnu.linkonce.r.*)
  *(.rodata .rodata.__unpaged .rodata.__unpaged.*)
 *(.rodata.thread_check_canaries.str1.1)
 *(.rodata.__print_abort_info.str1.1)
 *(.rodata.abort_print.str1.1)
 *(.rodata.abort_print_error.str1.1)
 *(.rodata.abort_handler.str1.1)
 *(.rodata.str1.1.core/arch/arm/kernel/abort.c)
 *(.rodata.CSWTCH.26)
 *(.rodata.trace_ext_prefix)
 *(.rodata.boot_init_secondary.str1.1)
 *(.rodata.__func__.0)
 *(.rodata.dummy)
 *(.rodata.core_mmu_type_to_attr.str1.1)
 *(.rodata.pager_deploy_page.str1.1)
 *(.rodata.tee_pager_handle_fault.str1.1)
 *(.rodata.__func__.1)
 *(.rodata.stm32mp1_itamper_action.str1.1)
 *(.rodata.stm32mp1_etamper_action.str1.1)
 *(.rodata.console_init.str1.1)
 *(.rodata.get_part_number.constprop.0.str1.1)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/main.c)
 *(.rodata.__func__.6)
 *(.rodata.itamper_name)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/scmi_server.c)
 *(.rodata.scmi_channel)
 *(.rodata.get_freq.str1.1)
 *(.rodata.stm32mp_start_clock_calib.str1.1)
 *(.rodata.ddr_set_sr_mode.str1.1)
 *(.rodata.CSWTCH.19)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/drivers/stm32mp1_pmic.c)
 *(.rodata.pmic_reguls)
 *(.rodata.pmic_sw_ops)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/drivers/stm32mp1_pwr.c)
 *(.rodata.pwr_regulators)
 *(.rodata.stm32mp_syscfg_enable_io_compensation.str1.1)
 *(.rodata.allowed_regs)
 *(.rodata.rcc_wakeup_it_handler.str1.1)
 *(.rodata.stm32_enter_cstop.str1.1)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/pm/low_power.c)
 *(.rodata.config_pwr)
 *(.rodata.need_to_backup_cpu_context.str1.1)
 *(.rodata.psci_cpu_off.str1.1)
 *(.rodata.psci_system_suspend.str1.1)
 *(.rodata.psci_system_reset.str1.1)
 *(.rodata.CSWTCH.13)
 *(.rodata.__func__.2)
 *(.rodata.last4)
 *(.rodata.gic_ops)
 *(.rodata.stm32_gpio_set_level.str1.1)
 *(.rodata.__func__.3)
 *(.rodata.__func__.4)
 *(.rodata.__func__.5)
 *(.rodata.stm32_gpio_ops)
 *(.rodata.stm32_iwdg_it_handler.str1.1)
 *(.rodata.conceal_seed_error.constprop.0.str1.1)
 *(.rodata.crypto_rng_read.str1.1)
 *(.rodata.stm32_rtc_diff_calendar.str1.1)
 *(.rodata.stm32_uart_serial_ops)
 *(.rodata.find_plat_mask.str1.1)
 *(.rodata.stpmic1_regulator_levels_mv.str1.1)
 *(.rodata.stpmic1_active_discharge_mode_set.str1.1)
 *(.rodata.str1.1.core/drivers/stpmic1.c)
 *(.rodata.buck1_voltage_table)
 *(.rodata.buck2_voltage_table)
 *(.rodata.buck3_voltage_table)
 *(.rodata.buck4_voltage_table)
 *(.rodata.fixed_5v_voltage_table)
 *(.rodata.ldo1_voltage_table)
 *(.rodata.ldo2_voltage_table)
 *(.rodata.ldo3_special_mode_table)
 *(.rodata.ldo3_voltage_table)
 *(.rodata.ldo4_voltage_table)
 *(.rodata.ldo5_voltage_table)
 *(.rodata.ldo6_voltage_table)
 *(.rodata.regulators_table)
 *(.rodata.vref_ddr_voltage_table)
 *(.rodata.stm32_tim_counter_ops)
 *(.rodata.stm32mp1_set_clkdiv.str1.1)
 *(.rodata.pll_output.str1.1)
 *(.rodata.restore_pll34_state.str1.1)
 *(.rodata.stm32mp1_set_clksrc.str1.1)
 *(.rodata.pll1_config_from_opp_khz.str1.1)
 *(.rodata.stm32mp1_clk_restore_context_for_stop.str1.1)
 *(.rodata.__func__.7)
 *(.rodata.__func__.8)
 *(.rodata.__func__.9)
 *(.rodata.pllncfgr2)
 *(.rodata.stm32mp1_axi_div)
 *(.rodata.stm32mp1_clk_gate)
 *(.rodata.stm32mp1_clk_on)
 *(.rodata.stm32mp1_clk_pll)
 *(.rodata.stm32mp1_mcu_div)
 *(.rodata.stm32mp1_mpu_apbx_div)
 *(.rodata.stm32mp1_pll)
 *(.rodata.regulator_disable.str1.1)
 *(.rodata.regulator_pm.str1.1)
 *(.rodata.__func__.10)
 *(.rodata.call_callbacks.str1.1)
 *(.rodata.no_name)
 *(.rodata.itr_handle.str1.1)
 *(.rodata.__do_panic.str1.1)
 *(.rodata.TE0)
 *(.rodata.Te4)
 *(.rodata.K)
 *(.rodata.kprintf.constprop.0.str1.1)
 *(.rodata.HEXDIGITS)
 *(.rodata.hexdigits)
 *(.rodata.trace_vprintf.str1.1)
 *(.rodata.lvl_strs.0)
  . = ALIGN(8);
  __rodata_end = .;
 }
 .got : { *(.got.plt) *(.got) }
 .note.gnu.property : { *(.note.gnu.property) }
 .plt : { *(.plt) }
 .ctors : ALIGN(8) {
  __ctor_list = .;
  KEEP(*(.ctors .ctors.* .init_array .init_array.*))
  __ctor_end = .;
 }
 .dtors : ALIGN(8) {
  __dtor_list = .;
  KEEP(*(.dtors .dtors.* .fini_array .fini_array.*))
  __dtor_end = .;
 }
 .ARM.exidx : {
  __exidx_start = .;
  *(.ARM.exidx* .gnu.linkonce.armexidx.*)
  __exidx_end = .;
 }
 .ARM.extab : {
  __extab_start = .;
  *(.ARM.extab*)
  __extab_end = .;
 }
 . = ALIGN((1 << (12)));
 __flatmap_unpg_ro_size = . - __flatmap_unpg_ro_start;
 __flatmap_unpg_rw_start = .;
 .data : ALIGN(8) {
  __data_start_rom = .;
  __data_start = .;
  *(.data .data.* .gnu.linkonce.d.*)
  . = ALIGN(8);
 }
 .bss : {
  __data_end = .;
  __bss_start = .;
  *(.bss .bss.*)
  *(.gnu.linkonce.b.*)
  *(COMMON)
  . = ALIGN(8);
  __bss_end = .;
 }
 .heap1 (NOLOAD) : {
  __heap1_start = .;
  . = ALIGN(4 * 1024);
  __heap1_end = .;
 }
 .nozi (NOLOAD) : {
  __nozi_start = .;
  KEEP(*(.nozi .nozi.*))
  . = ALIGN(16);
  __nozi_end = .;
  __nozi_stack_start = .;
  KEEP(*(.nozi_stack .nozi_stack.*))
  . = ALIGN(8);
  __nozi_stack_end = .;
 }
 .heap2 (NOLOAD) : {
  __heap2_start = .;
  . += 49152 - (__heap1_end - __heap1_start);
  . = ALIGN((1 << (12)));
  __heap2_end = .;
 }
 __flatmap_unpg_rw_size = . - __flatmap_unpg_rw_start;
 __init_start = .;
 __flatmap_init_rx_start = .;
 ASSERT(!(__flatmap_init_rx_start & ((1 << (12)) - 1)),
  "read-write memory is not paged aligned")
 .text_init : {
 *(.text.udelay)
 *(.text.mdelay)
 *(.text.cpu_idle)
 *(.text.__cpu_spin_lock)
 *(.text.__cpu_spin_trylock)
 *(.text.__cpu_spin_unlock)
 *(.text.tlbi_all)
 *(.text.tlbi_mva_allasid)
 *(.text.dcache_cleaninv_range)
 *(.text.dcache_clean_range)
 *(.text.dcache_inv_range)
 *(.text.dcache_clean_range_pou)
 *(.text.do_dcsw_op)
 *(.text.dcache_op_louis)
 *(.text.dcache_op_all)
 *(.text.dcache_op_level1)
 *(.text.icache_inv_all)
 *(.text.icache_inv_range)
 *(.text.thread_set_abt_sp)
 *(.text.thread_set_und_sp)
 *(.text.thread_set_irq_sp)
 *(.text.thread_set_fiq_sp)
 *(.text.thread_resume)
 *(.text.thread_save_state)
 *(.text.thread_init_vbar)
 *(.text.thread_unwind_user_mode)
 *(.text.thread_excp_vect)
 *(.text.thread_check_canaries)
 *(.text.thread_lock_global)
 *(.text.thread_unlock_global)
 *(.text.thread_get_exceptions)
 *(.text.thread_set_exceptions)
 *(.text.thread_mask_exceptions)
 *(.text.thread_unmask_exceptions)
 *(.text.thread_get_core_local)
 *(.text.thread_clr_boot_thread)
 *(.text.thread_get_tmp_sp)
 *(.text.thread_is_from_abort_mode)
 *(.text.thread_get_id_may_fail)
 *(.text.thread_lazy_save_ns_vfp)
 *(.text.thread_resume_from_rpc)
 *(.text.thread_alloc_and_run)
 *(.text.thread_lazy_restore_ns_vfp)
 *(.text.thread_state_free)
 *(.text.thread_init_threads)
 *(.text.thread_init_boot_thread)
 *(.text.thread_init_thread_core_local)
 *(.text.thread_init_primary)
 *(.text.thread_init_per_cpu)
 *(.text.thread_get_tsd)
 *(.text.thread_get_ctx_regs)
 *(.text.thread_restore_foreign_intr)
 *(.text.thread_kernel_save_vfp)
 *(.text.thread_kernel_restore_vfp)
 *(.text.thread_user_enable_vfp)
 *(.text.thread_user_save_vfp)
 *(.text.thread_state_suspend)
 *(.text.thread_svc_handler)
 *(.text.thread_handle_fast_smc)
 *(.text.thread_handle_std_smc)
 *(.text.thread_disable_prealloc_rpc_cache)
 *(.text.thread_enable_prealloc_rpc_cache)
 *(.text.thread_std_smc_entry)
 *(.text.thread_foreign_intr_exit)
 *(.text.save_abort_info_in_tsd)
 *(.text.__print_abort_info)
 *(.text.handle_user_mode_panic.isra.0)
 *(.text.abort_print)
 *(.text.abort_print_error)
 *(.text.abort_is_user_exception)
 *(.text.abort_is_write_fault)
 *(.text.abort_handler)
 *(.text.vfp_is_enabled)
 *(.text.vfp_enable)
 *(.text.vfp_disable)
 *(.text.vfp_lazy_save_state_init)
 *(.text.vfp_lazy_save_state_final)
 *(.text.vfp_lazy_restore_state)
 *(.text.vfp_save_extension_regs)
 *(.text.vfp_restore_extension_regs)
 *(.text.vfp_write_fpexc)
 *(.text.vfp_read_fpexc)
 *(.text.vfp_write_fpscr)
 *(.text.vfp_read_fpscr)
 *(.text.plat_trace_ext_puts)
 *(.text.trace_ext_puts)
 *(.text.trace_ext_get_thread_id)
 *(.text.trace_ext_get_core_id)
 *(.text.get_core_pos_mpidr)
 *(.text.temp_set_mode)
 *(.text.read_mode_sp)
 *(.text.read_mode_lr)
 *(.text.plat_primary_init_early)
 *(.text.init_sec_mon)
 *(.text.boot_init_primary_early)
 *(.text.boot_init_secondary)
 *(.text.boot_set_core_ns_entry)
 *(.text.boot_core_release)
 *(.text.boot_core_hpen)
 *(.text._start)
 *(.text.unhandled_cpu)
 *(.text.dummy.boot_init_primary_late)
 *(.text.dummy.__thread_std_smc_entry)
 *(.text.pa_is_in_map)
 *(.text.find_map_by_type_and_pa)
 *(.text.find_map_by_pa)
 *(.text.cmp_mmap_by_lower_va)
 *(.text._pbuf_is_inside)
 *(.text.cmp_init_mem_map)
 *(.text.phys_to_virt.part.0)
 *(.text.add_va_space.constprop.0)
 *(.text.map_is_tee_ram.isra.0)
 *(.text.core_mmu_nsec_ddr_is_defined)
 *(.text.core_mmu_type_to_attr)
 *(.text.core_init_mmu_map)
 *(.text.core_pbuf_is)
 *(.text.core_mmu_get_mem_by_type)
 *(.text.core_mmu_get_type_by_pa)
 *(.text.tlbi_mva_range)
 *(.text.core_mmu_set_entry)
 *(.text.core_mmu_get_entry)
 *(.text.core_mmu_map_region)
 *(.text.virt_to_phys)
 *(.text.phys_to_virt)
 *(.text.phys_to_virt_io)
 *(.text.cpu_mmu_enabled)
 *(.text.io_pa_or_va)
 *(.text.io_pa_or_va_secure)
 *(.text.core_mmu_init_ta_ram)
 *(.text.get_pgt_count)
 *(.text.find_pager_table_may_fail)
 *(.text.region_va2tblidx)
 *(.text.pmem_assign_fobj_page)
 *(.text.pmem_find)
 *(.text.alloc_region)
 *(.text.tblidx_get_entry)
 *(.text.tblidx_set_entry)
 *(.text.to_user_mode_ctx)
 *(.text.tblidx_tlbi_entry)
 *(.text.find_region)
 *(.text.find_uta_region)
 *(.text.fobj_get)
 *(.text.fobj_put)
 *(.text.pager_unlock)
 *(.text.make_dirty_page.isra.0)
 *(.text.get_pmem_pa.isra.0)
 *(.text.pager_deploy_page)
 *(.text.tee_pager_unhide_page)
 *(.text.make_iv_available)
 *(.text.pmem_get_region_tblidx.isra.0)
 *(.text.pmem_unmap)
 *(.text.pager_lock_check_stack)
 *(.text.region_insert)
 *(.text.tee_pager_release_phys)
 *(.text.tee_pager_get_stats)
 *(.text.tee_pager_get_table_info)
 *(.text.tee_pager_phys_to_virt)
 *(.text.tee_pager_set_alias_area)
 *(.text.tee_pager_early_init)
 *(.text.tee_pager_add_core_region)
 *(.text.tee_pager_handle_fault)
 *(.text.tee_pager_add_pages)
 *(.text.tee_pager_alloc)
 *(.text.core_init_mmu_prtn_tee)
 *(.text.core_init_mmu)
 *(.text.core_mmu_place_tee_ram_at_top)
 *(.text.core_init_mmu_regs)
 *(.text.core_mmu_find_table)
 *(.text.core_mmu_entry_to_finer_grained)
 *(.text.core_mmu_set_entry_primitive)
 *(.text.core_mmu_get_entry_primitive)
 *(.text.core_mmu_get_user_va_range)
 *(.text.core_mmu_user_mapping_is_active)
 *(.text.core_mmu_get_user_map)
 *(.text.core_mmu_set_user_map)
 *(.text.core_mmu_get_fault_type)
 *(.text.tee_mm_stats_allocated)
 *(.text.cpu_spin_lock_xsave_no_dldetect)
 *(.text.cpu_spin_unlock_xrestore)
 *(.text.pfree.isra.0)
 *(.text.tee_mm_init)
 *(.text.tee_mm_alloc)
 *(.text.tee_mm_alloc2)
 *(.text.tee_mm_free)
 *(.text.tee_mm_final)
 *(.text.tee_mm_get_bytes)
 *(.text.tee_mm_is_empty)
 *(.text.tee_mm_get_smem)
 *(.text.pgt_init)
 *(.text.tee_entry_get_api_call_count)
 *(.text.tee_entry_get_api_uuid)
 *(.text.tee_entry_get_api_revision)
 *(.text.tee_entry_get_os_uuid)
 *(.text.tee_entry_get_os_revision)
 *(.text.__tee_entry_fast)
 *(.text.tee_entry_fast)
 *(.text.stm32_dbgmcu_base)
 *(.text.console_init)
 *(.text.stm32mp1_dbgmcu_get_chip_dev_id)
 *(.text.get_part_number.constprop.0)
 *(.text.itr_core_handler)
 *(.text.main_secondary_init_gic)
 *(.text.get_gicd_base)
 *(.text.may_spin_lock)
 *(.text.may_spin_unlock)
 *(.text.stm32mp_bkpreg)
 *(.text.stm32mp_bkpsram_base)
 *(.text.stm32mp_stgen_base)
 *(.text.stm32mp_supports_hw_cryp)
 *(.text.stm32mp_supports_second_core)
 *(.text.plat_cpu_reset_early)
 *(.text.io_mask32_stm32shregs)
 *(.text.get_ddrctrl_base)
 *(.text.do_sw_handshake)
 *(.text.ddr_set_sr_mode)
 *(.text.timeout_init_us.constprop.0)
 *(.text.do_sw_ack)
 *(.text.get_ddrphy_calibration)
 *(.text.ddr_standby_sr_entry)
 *(.text.ddr_standby_sr_exit)
 *(.text.ddr_save_sr_mode)
 *(.text.ddr_restore_sr_mode)
 *(.text.stm32mp_with_pmic)
 *(.text.stm32mp_pm_get_pmic)
 *(.text.stm32_pwr_base)
 *(.text.stm32_rcc_base)
 *(.text.stm32_reset_system)
 *(.text.sm_platform_handler)
 *(.text.pm_domain_scv_handler)
 *(.text.pwr_scv_handler)
 *(.text.get_retram_resume_ctx)
 *(.text.load_earlyboot_pm_mailbox)
 *(.text.enable_pm_mailbox)
 *(.text.gate_pm_context_clocks.part.0)
 *(.text.gate_pm_context_clocks.constprop.0)
 *(.text.stm32mp_pm_wipe_context)
 *(.text.stm32mp_pm_save_context)
 *(.text.stm32mp_pm_restore_context)
 *(.text.stm32mp_pm_shutdown_context)
 *(.text.cpu_wfi)
 *(.text.stm32mp_mask_timer)
 *(.text.stm32_pm_cpu_wfi)
 *(.text.stm32_enter_cstop)
 *(.text.stm32_exit_cstop)
 *(.text.stm32_enter_cstop_shutdown)
 *(.text.stm32_enter_csleep)
 *(.text.plat_panic)
 *(.text.stm32_pm_cpu_power_down_wfi)
 *(.text.stm32mp_bkpsram_resume)
 *(.text.stm32mp_ccm_encrypt_teeram)
 *(.text.stm32mp_sysram_resume)
 *(.text.stm32mp_cpu_reset_state)
 *(.text.get_pm_domain_state)
 *(.text.stm32mp1_is_retram_during_standby)
 *(.text.need_to_backup_cpu_context)
 *(.text.need_to_backup_stop_context)
 *(.text.stm32mp1_set_pm_domain_state)
 *(.text.stm32mp1_get_lp_soc_mode)
 *(.text.plat_suspend)
 *(.text.psci_affinity_info)
 *(.text.stm32mp_register_online_cpu)
 *(.text.psci_cpu_on)
 *(.text.psci_cpu_off)
 *(.text.psci_system_suspend)
 *(.text.psci_system_off)
 *(.text.psci_system_reset)
 *(.text.psci_features)
 *(.text.psci_version)
 *(.text.sm_save_unbanked_regs)
 *(.text.sm_restore_unbanked_regs)
 *(.text.sm_smc_entry)
 *(.text.sm_fiq_entry)
 *(.text.sm_vect_table)
 *(.text.sm_vect_table_a15)
 *(.text.sm_vect_table_bpiall)
 *(.text.sm_init)
 *(.text.sm_get_nsec_ctx)
 *(.text.sm_from_nsec)
 *(.text.sm_pm_cpu_suspend_save)
 *(.text.sm_pm_cpu_suspend)
 *(.text.sm_pm_cpu_do_suspend)
 *(.text.sm_pm_cpu_resume)
 *(.text.sm_pm_cpu_do_resume)
 *(.text.smc_std_handler)
 *(.text.psci_cpu_suspend)
 *(.text.psci_migrate)
 *(.text.psci_migrate_info_type)
 *(.text.psci_migrate_info_up_cpu)
 *(.text.psci_mem_protect)
 *(.text.psci_mem_chk_range)
 *(.text.psci_system_reset2)
 *(.text.psci_node_hw_state)
 *(.text.tee_psci_handler)
 *(.text.psci_disable_smp)
 *(.text.psci_armv7_cpu_off)
 *(.text.gic_cpu_init)
 *(.text.gic_it_handle)
 *(.text.bsec_base)
 *(.text.bsec_status)
 *(.text.is_invalid_mode)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout.part.0)
 *(.text.stm32_bsec_read_otp)
 *(.text.stm32_bsec_read_debug_conf)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout)
 *(.text.stm32_gpio_get_bank)
 *(.text.set_gpio_cfg)
 *(.text.stm32_pinctrl_load_config)
 *(.text.iwdg_refresh)
 *(.text.stm32_iwdg_refresh)
 *(.text.timeout_init_us)
 *(.text.get_base)
 *(.text.i2c_ack_failed)
 *(.text.i2c_transfer_config)
 *(.text.i2c_wait_stop)
 *(.text.wait_isr_event)
 *(.text.i2c_wait_txis)
 *(.text.stm32_i2c_read_write_membyte)
 *(.text.stm32_i2c_resume)
 *(.text.conceal_seed_error.constprop.0)
 *(.text.get_rng_bytes_relaxed)
 *(.text.crypto_rng_read)
 *(.text.stm32_is_a_leap_year)
 *(.text.stm32_rtc_get_second_fraction)
 *(.text.stm32_rtc_read_calendar)
 *(.text.stm32_rtc_get_date.isra.0)
 *(.text.stm32_rtc_get_time.isra.0)
 *(.text.stm32_rtc_get_calendar)
 *(.text.stm32_rtc_diff_calendar)
 *(.text.loc_have_rx_data)
 *(.text.loc_putc)
 *(.text.loc_flush)
 *(.text.loc_getchar)
 *(.text.stm32_uart_init)
 *(.text.stpmic1_register_read)
 *(.text.stpmic1_register_write)
 *(.text.stpmic1_register_update)
 *(.text.stpmic1_switch_off)
 *(.text.clk_disable_no_lock)
 *(.text.clk_enable_no_lock)
 *(.text.clk_enable)
 *(.text.clk_disable)
 *(.text.clock_id_to_clk)
 *(.text.save_pll34_state)
 *(.text.enable_kernel_clocks)
 *(.text.pll_start)
 *(.text.stm32mp1_set_clkdiv)
 *(.text.pll_output)
 *(.text.restore_pll34_state)
 *(.text.stm32mp1_clk_lp_save_opp_pll1_settings)
 *(.text.stm32mp_rcc_clock_id_to_clk)
 *(.text.stm32mp1_clk_save_context_for_stop)
 *(.text.stm32mp1_clk_restore_context_for_stop)
 *(.text.console_putc)
 *(.text.console_flush)
 *(.text.register_serial_console)
 *(.text.call_callbacks)
 *(.text.pm_change_state)
 *(.text.itr_handle)
 *(.text.itr_raise_sgi)
 *(.text.itr_set_pmr)
 *(.text.itr_set_ipriority)
 *(.text.__do_panic)
 *(.text.refcount_inc)
 *(.text.refcount_dec)
 *(.text.is_valid_conf_and_notnull_size)
 *(.text.core_is_buffer_inside)
 *(.text.core_is_buffer_intersect)
 *(.text.ts_get_current_session_may_fail)
 *(.text.ts_get_current_session)
 *(.text.scattered_array_relax_ptr)
 *(.text.is_user_ta_ctx)
 *(.text.fobj_ro_paged_alloc)
 *(.text.fobj_locked_paged_alloc)
 *(.text.mobj_get_pa)
 *(.text.vm_pa2va)
 *(.text.hash_sha256_check)
 *(.text.sha256_init)
 *(.text._sha256_compress)
 *(.text.sha256_compress)
 *(.text.sha256_done)
 *(.text.sha256_process)
 *(.text.burn_stack)
 *(.text.zeromem)
 *(.text.buf_get_pos)
 *(.text.raw_malloc_return_hook)
 *(.text.bget)
 *(.text.bgetz)
 *(.text.brel)
 *(.text.bgetr)
 *(.text.bpool)
 *(.text.raw_malloc)
 *(.text.raw_free)
 *(.text.free_helper)
 *(.text.raw_calloc)
 *(.text.raw_realloc)
 *(.text.gen_malloc_add_pool)
 *(.text.malloc)
 *(.text.calloc)
 *(.text.free)
 *(.text.malloc_add_pool)
 *(.text.swapfunc)
 *(.text.med3)
 *(.text.qsort)
 *(.text.memchr)
 *(.text.memcpy)
 *(.text.memmove)
 *(.text.memset)
 *(.text.strcmp)
 *(.text.strlen)
 *(.text.__aeabi_uldivmod)
 *(.text.ul_div_qr)
 *(.text.__ul_divmod)
 *(.text.__vsnprintf)
 *(.text.vsnprintk)
 *(.text.snprintk)
 *(.text.kprintf.constprop.0)
 *(.text.trace_vprintf)
 *(.text.trace_printf)
 *(.text.consttime_memcmp)
 *(.text.memzero_explicit)
  KEEP(*(.text.startup.*));
  KEEP(*(.text._GLOBAL__sub_*));
  . = ALIGN(8);
 }
 __flatmap_init_rx_size = . - __flatmap_init_rx_start;
 __flatmap_init_ro_start = .;
 .rodata_init : {
 *(.rodata.thread_check_canaries.str1.1)
 *(.rodata.__print_abort_info.str1.1)
 *(.rodata.abort_print.str1.1)
 *(.rodata.abort_print_error.str1.1)
 *(.rodata.abort_handler.str1.1)
 *(.rodata.str1.1.core/arch/arm/kernel/abort.c)
 *(.rodata.CSWTCH.26)
 *(.rodata.trace_ext_prefix)
 *(.rodata.boot_init_primary_early.str1.1)
 *(.rodata.boot_init_secondary.str1.1)
 *(.rodata.__func__.0)
 *(.rodata.__func__.1)
 *(.rodata.__func__.2)
 *(.rodata.dummy)
 *(.rodata.add_va_space.constprop.0.str1.1)
 *(.rodata.core_mmu_type_to_attr.str1.1)
 *(.rodata.core_init_mmu_map.str1.1)
 *(.rodata.core_mmu_map_region.str1.1)
 *(.rodata.core_mmu_init_ta_ram.str1.1)
 *(.rodata.str1.1.core/arch/arm/mm/core_mmu.c)
 *(.rodata.__func__.3)
 *(.rodata.alloc_region.str1.1)
 *(.rodata.pager_deploy_page.str1.1)
 *(.rodata.tee_pager_early_init.str1.1)
 *(.rodata.tee_pager_add_core_region.str1.1)
 *(.rodata.tee_pager_handle_fault.str1.1)
 *(.rodata.tee_pager_add_pages.str1.1)
 *(.rodata.core_init_mmu_prtn_tee.str1.1)
 *(.rodata.core_mmu_entry_to_finer_grained.str1.1)
 *(.rodata.tee_mm_alloc.str1.1)
 *(.rodata.tee_mm_free.str1.1)
 *(.rodata.console_init.str1.1)
 *(.rodata.get_part_number.constprop.0.str1.1)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/main.c)
 *(.rodata.__func__.6)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/scmi_server.c)
 *(.rodata.ddr_set_sr_mode.str1.1)
 *(.rodata.CSWTCH.19)
 *(.rodata.allowed_regs)
 *(.rodata.stm32_enter_cstop.str1.1)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/pm/low_power.c)
 *(.rodata.config_pwr)
 *(.rodata.need_to_backup_cpu_context.str1.1)
 *(.rodata.psci_cpu_off.str1.1)
 *(.rodata.psci_system_suspend.str1.1)
 *(.rodata.psci_system_reset.str1.1)
 *(.rodata.CSWTCH.13)
 *(.rodata.stm32_gpio_set_level.str1.1)
 *(.rodata.conceal_seed_error.constprop.0.str1.1)
 *(.rodata.crypto_rng_read.str1.1)
 *(.rodata.stm32_rtc_diff_calendar.str1.1)
 *(.rodata.stm32_uart_serial_ops)
 *(.rodata.stm32mp1_set_clkdiv.str1.1)
 *(.rodata.pll_output.str1.1)
 *(.rodata.restore_pll34_state.str1.1)
 *(.rodata.stm32mp1_clk_restore_context_for_stop.str1.1)
 *(.rodata.__func__.5)
 *(.rodata.__func__.7)
 *(.rodata.__func__.9)
 *(.rodata.stm32mp1_clk_gate)
 *(.rodata.stm32mp1_clk_on)
 *(.rodata.stm32mp1_clk_pll)
 *(.rodata.call_callbacks.str1.1)
 *(.rodata.itr_handle.str1.1)
 *(.rodata.__do_panic.str1.1)
 *(.rodata.K)
 *(.rodata.kprintf.constprop.0.str1.1)
 *(.rodata.HEXDIGITS)
 *(.rodata.hexdigits)
 *(.rodata.trace_vprintf.str1.1)
 *(.rodata.lvl_strs.0)
  . = ALIGN(8);
  KEEP(*(SORT(.scattered_array*)));
  . = ALIGN(8);
  __rodata_init_end = .;
 }
 __init_end = ALIGN(__rodata_init_end, (1 << (12)));
 __get_tee_init_end = __init_end;
 __init_size = __init_end - __init_start;
 __flatmap_init_ro_size = __init_end - __flatmap_init_ro_start;
 .rodata_pageable : ALIGN(8) {
  *(.rodata*)
 }
 .text_pageable : ALIGN(8) {
  *(.text*)
  . = ALIGN((1 << (12)));
 }
 __pageable_part_end = .;
 __pageable_part_start = __init_end;
 __pageable_start = __init_start;
 __pageable_end = __pageable_part_end;
 ASSERT(0x2ffc0000 >= 0x2ffc0000,
  "Load address before start of physical memory")
 ASSERT(0x2ffc0000 < (0x2ffc0000 + 0x0003f000),
  "Load address after end of physical memory")
 ASSERT((0x2ffc0000 + 0x0003f000 - __init_end) >
  (1 << (12)), "Too few free pages to initialize paging")
 __end = .;
 ASSERT(. <= (0x2ffc0000 + (1 << (21))),
  "TEE_RAM_VA_SIZE is too small")
 . = 0x2ffc0000 + (1 << (21));
 _end_of_ram = .;
 .dynamic : { *(.dynamic) }
 .hash : { *(.hash) }
 .dynsym : { *(.dynsym) }
 .dynstr : { *(.dynstr) }
 .rel : {
  *(.rel.*)
 }
 .rela : {
  *(.rela.*)
 }
 ASSERT(SIZEOF(.rel) == 0, "Relocation entries not expected")
 ASSERT(SIZEOF(.rela) == 0, "Relocation entries not expected")
 /DISCARD/ : {
  *(.comment .note .eh_frame .interp)
  *(__keep_meta_vars*)
 }
}
__vcore_unpg_rx_start = __flatmap_unpg_rx_start;
__vcore_unpg_ro_start = __flatmap_unpg_ro_start;
__vcore_unpg_rx_size = __flatmap_unpg_rx_size + __flatmap_unpg_ro_size;
__vcore_unpg_ro_size = 0;
__vcore_unpg_rx_end = __vcore_unpg_rx_start + __vcore_unpg_rx_size;
__vcore_unpg_ro_end = __vcore_unpg_ro_start + __vcore_unpg_ro_size;
__vcore_unpg_rw_start = __flatmap_unpg_rw_start;
__vcore_unpg_rw_size = __flatmap_unpg_rw_size;
__vcore_unpg_rw_end = __vcore_unpg_rw_start + __vcore_unpg_rw_size;
__vcore_init_rx_start = __flatmap_init_rx_start;
__vcore_init_ro_start = __flatmap_init_ro_start;
__vcore_init_rx_size = __flatmap_init_rx_size + __flatmap_init_ro_size +
         (0x2ffc0000 + 0x0003f000 - (__flatmap_init_ro_start + __flatmap_init_ro_size));
__vcore_init_ro_size = 0;
__vcore_init_rx_end = __vcore_init_rx_start + __vcore_init_rx_size;
__vcore_init_ro_end = __vcore_init_ro_start + __vcore_init_ro_size;
